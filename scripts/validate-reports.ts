/**
 * Validate JS-generated reports against Rust-generated report.json files.
 *
 * Compares key fields from the SQLite database (generated by generate-reports.ts)
 * against the original JSON reports (generated by Rust).
 *
 * Usage:
 *   bun scripts/validate-reports.ts [js-db-path] [rust-reports-dir]
 */

import { Database } from "bun:sqlite";
import { readFileSync, readdirSync, statSync, existsSync } from "fs";
import { join, resolve } from "path";

const JS_DB_PATH = process.argv[2] || "/tmp/rcv-full-test.sqlite3";
const RUST_REPORTS_DIR = process.argv[3] || "report_pipeline/reports";

// ---------- Types ----------

interface RustReport {
  info: {
    jurisdictionPath: string;
    electionPath: string;
    office: string;
    name: string;
  };
  ballotCount: number;
  numCandidates: number;
  winner: number | null;
  condorcet?: number | null;
  candidates: Array<{ name: string }>;
  rounds: Array<{
    allocations: Array<{ allocatee: number | string; votes: number }>;
    undervote: number;
    overvote: number;
    continuingBallots: number;
    transfers: Array<{ from: number; to: number | string; count: number }>;
  }>;
  totalVotes: Array<{
    candidate: number;
    firstRoundVotes: number;
    transferVotes: number;
    roundEliminated?: number | null;
  }>;
  pairwisePreferences: { rows: any[]; cols: any[]; entries: any[][] };
  smithSet: number[];
}

// ---------- Find all report.json files ----------

function findReportFiles(dir: string): string[] {
  const files: string[] = [];
  function walk(d: string) {
    for (const entry of readdirSync(d)) {
      const full = join(d, entry);
      if (statSync(full).isDirectory()) {
        walk(full);
      } else if (entry === "report.json") {
        files.push(full);
      }
    }
  }
  walk(dir);
  return files;
}

// ---------- Comparison ----------

interface ValidationResult {
  key: string;
  passed: boolean;
  failures: string[];
}

function floatClose(a: number, b: number, tolerance = 0.001): boolean {
  return Math.abs(a - b) < tolerance;
}

function validate(
  rustReport: RustReport,
  db: Database,
  key: string
): ValidationResult {
  const failures: string[] = [];
  const info = rustReport.info;
  const path = `${info.jurisdictionPath}/${info.electionPath}`;

  // Find the corresponding report in the JS DB
  const jsRow = db
    .prepare("SELECT * FROM reports WHERE path = ? AND office = ?")
    .get(path, info.office) as any;

  if (!jsRow) {
    return { key, passed: false, failures: ["Report not found in JS database"] };
  }

  // Ballot count
  if (jsRow.ballotCount !== rustReport.ballotCount) {
    failures.push(
      `ballotCount: JS=${jsRow.ballotCount}, Rust=${rustReport.ballotCount}`
    );
  }

  // Winner
  if (jsRow.winner_candidate_index !== rustReport.winner) {
    failures.push(
      `winner: JS=${jsRow.winner_candidate_index}, Rust=${rustReport.winner}`
    );
  }

  // Condorcet
  const rustCondorcet = rustReport.condorcet ?? null;
  if (jsRow.condorcet !== rustCondorcet) {
    failures.push(
      `condorcet: JS=${jsRow.condorcet}, Rust=${rustCondorcet}`
    );
  }

  // Number of candidates
  if (jsRow.numCandidates !== rustReport.numCandidates) {
    failures.push(
      `numCandidates: JS=${jsRow.numCandidates}, Rust=${rustReport.numCandidates}`
    );
  }

  // Round count
  const jsRoundCount = (
    db.prepare("SELECT COUNT(*) as cnt FROM rounds WHERE report_id = ?").get(jsRow.id) as any
  ).cnt;
  if (jsRoundCount !== rustReport.rounds.length) {
    failures.push(
      `rounds: JS=${jsRoundCount}, Rust=${rustReport.rounds.length}`
    );
  }

  // Candidate count
  const jsCandCount = (
    db.prepare("SELECT COUNT(*) as cnt FROM candidates WHERE report_id = ?").get(jsRow.id) as any
  ).cnt;
  if (jsCandCount !== rustReport.candidates.length) {
    failures.push(
      `candidates: JS=${jsCandCount}, Rust=${rustReport.candidates.length}`
    );
  }

  // Candidate names
  const jsCandidates = db
    .prepare("SELECT * FROM candidates WHERE report_id = ? ORDER BY candidate_index")
    .all(jsRow.id) as any[];
  for (let i = 0; i < Math.min(jsCandidates.length, rustReport.candidates.length); i++) {
    if (jsCandidates[i].name !== rustReport.candidates[i].name) {
      failures.push(
        `candidate[${i}] name: JS="${jsCandidates[i].name}", Rust="${rustReport.candidates[i].name}"`
      );
    }
  }

  // Total votes per candidate
  for (const rustVote of rustReport.totalVotes) {
    const jsCandidate = jsCandidates.find(
      (c: any) => c.candidate_index === rustVote.candidate
    );
    if (!jsCandidate) {
      failures.push(`totalVotes: candidate ${rustVote.candidate} not found in JS`);
      continue;
    }
    if (jsCandidate.firstRoundVotes !== rustVote.firstRoundVotes) {
      failures.push(
        `totalVotes[${rustVote.candidate}] firstRound: JS=${jsCandidate.firstRoundVotes}, Rust=${rustVote.firstRoundVotes}`
      );
    }
    if (jsCandidate.transferVotes !== rustVote.transferVotes) {
      failures.push(
        `totalVotes[${rustVote.candidate}] transfer: JS=${jsCandidate.transferVotes}, Rust=${rustVote.transferVotes}`
      );
    }
  }

  // Round details: check vote allocations
  if (jsRoundCount === rustReport.rounds.length) {
    const jsRounds = db
      .prepare("SELECT * FROM rounds WHERE report_id = ? ORDER BY round_number")
      .all(jsRow.id) as any[];

    for (let r = 0; r < jsRounds.length; r++) {
      const jsRound = jsRounds[r];
      const rustRound = rustReport.rounds[r];

      if (jsRound.continuingBallots !== rustRound.continuingBallots) {
        failures.push(
          `round[${r}] continuingBallots: JS=${jsRound.continuingBallots}, Rust=${rustRound.continuingBallots}`
        );
      }

      // Check allocations
      const jsAllocs = db
        .prepare("SELECT * FROM allocations WHERE round_id = ?")
        .all(jsRound.id) as any[];

      // Sort both by allocatee for comparison
      const jsSorted = jsAllocs.sort((a: any, b: any) =>
        String(a.allocatee).localeCompare(String(b.allocatee))
      );
      const rustSorted = [...rustRound.allocations].sort((a, b) =>
        String(a.allocatee).localeCompare(String(b.allocatee))
      );

      for (let a = 0; a < Math.max(jsSorted.length, rustSorted.length); a++) {
        const jsAlloc = jsSorted[a];
        const rustAlloc = rustSorted[a];

        if (!jsAlloc || !rustAlloc) {
          failures.push(
            `round[${r}] alloc count mismatch: JS=${jsSorted.length}, Rust=${rustSorted.length}`
          );
          break;
        }

        if (String(jsAlloc.allocatee) !== String(rustAlloc.allocatee)) {
          failures.push(
            `round[${r}] alloc[${a}] allocatee: JS=${jsAlloc.allocatee}, Rust=${rustAlloc.allocatee}`
          );
        }

        if (jsAlloc.votes !== rustAlloc.votes) {
          failures.push(
            `round[${r}] alloc ${jsAlloc.allocatee} votes: JS=${jsAlloc.votes}, Rust=${rustAlloc.votes}`
          );
        }
      }
    }
  }

  // Smith set
  const jsSmithSet = JSON.parse(jsRow.smithSet || "[]") as number[];
  const rustSmithSet = rustReport.smithSet.sort((a, b) => a - b);
  jsSmithSet.sort((a, b) => a - b);
  if (JSON.stringify(jsSmithSet) !== JSON.stringify(rustSmithSet)) {
    failures.push(
      `smithSet: JS=${JSON.stringify(jsSmithSet)}, Rust=${JSON.stringify(rustSmithSet)}`
    );
  }

  // Pairwise: check a few entries for float tolerance
  const jsPairwise = JSON.parse(jsRow.pairwisePreferences || "{}");
  if (
    jsPairwise.entries &&
    rustReport.pairwisePreferences.entries &&
    jsPairwise.entries.length === rustReport.pairwisePreferences.entries.length
  ) {
    for (let i = 0; i < jsPairwise.entries.length; i++) {
      for (let j = 0; j < jsPairwise.entries[i].length; j++) {
        const jsEntry = jsPairwise.entries[i][j];
        const rustEntry = rustReport.pairwisePreferences.entries[i][j];

        if (jsEntry === null && rustEntry === null) continue;
        if (jsEntry === null || rustEntry === null) {
          failures.push(`pairwise[${i}][${j}] null mismatch`);
          continue;
        }

        if (jsEntry.numerator !== rustEntry.numerator) {
          failures.push(
            `pairwise[${i}][${j}] numerator: JS=${jsEntry.numerator}, Rust=${rustEntry.numerator}`
          );
        }
        if (jsEntry.denominator !== rustEntry.denominator) {
          failures.push(
            `pairwise[${i}][${j}] denominator: JS=${jsEntry.denominator}, Rust=${rustEntry.denominator}`
          );
        }
        if (!floatClose(jsEntry.frac, rustEntry.frac)) {
          failures.push(
            `pairwise[${i}][${j}] frac: JS=${jsEntry.frac}, Rust=${rustEntry.frac}`
          );
        }
      }
    }
  }

  return { key, passed: failures.length === 0, failures };
}

// ---------- Main ----------

function main() {
  const dbPath = resolve(JS_DB_PATH);
  const reportsDir = resolve(RUST_REPORTS_DIR);

  if (!existsSync(dbPath)) {
    console.error(`JS database not found: ${dbPath}`);
    process.exit(1);
  }

  if (!existsSync(reportsDir)) {
    console.error(`Rust reports directory not found: ${reportsDir}`);
    process.exit(1);
  }

  const db = new Database(dbPath, { readonly: true });
  const reportFiles = findReportFiles(reportsDir);
  console.log(`Found ${reportFiles.length} Rust report.json files`);

  // Check how many reports are in the JS DB
  const jsCount = (db.prepare("SELECT COUNT(*) as cnt FROM reports").get() as any).cnt;
  console.log(`JS database contains ${jsCount} reports`);

  let passed = 0;
  let failed = 0;
  let skipped = 0;
  const failedReports: ValidationResult[] = [];

  for (const filePath of reportFiles) {
    try {
      const raw = readFileSync(filePath, "utf-8");
      const rustReport: RustReport = JSON.parse(raw);
      const info = rustReport.info;
      const key = `${info.jurisdictionPath}/${info.electionPath}/${info.office}`;

      // Check if JS DB has this report
      const path = `${info.jurisdictionPath}/${info.electionPath}`;
      const jsRow = db
        .prepare("SELECT id FROM reports WHERE path = ? AND office = ?")
        .get(path, info.office);

      if (!jsRow) {
        skipped++;
        continue;
      }

      const result = validate(rustReport, db, key);

      if (result.passed) {
        passed++;
      } else {
        failed++;
        failedReports.push(result);
        if (failedReports.length <= 20) {
          console.error(`\nFAIL: ${result.key}`);
          for (const f of result.failures.slice(0, 5)) {
            console.error(`  - ${f}`);
          }
          if (result.failures.length > 5) {
            console.error(`  ... and ${result.failures.length - 5} more failures`);
          }
        }
      }
    } catch (err) {
      console.error(`Error reading ${filePath}: ${err}`);
      failed++;
    }
  }

  db.close();

  console.log(`\n--- Validation Results ---`);
  console.log(`Passed: ${passed}`);
  console.log(`Failed: ${failed}`);
  console.log(`Skipped (no preprocessed data): ${skipped}`);
  console.log(`Total Rust reports: ${reportFiles.length}`);

  if (failed > 0) {
    console.error(`\n${failed} reports have differences between JS and Rust output.`);
    process.exit(1);
  } else {
    console.log(`\nAll comparable reports match.`);
  }
}

main();
